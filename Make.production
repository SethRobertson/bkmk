# -*- makefile -*-
#
# $Id: Make.production,v 1.14 2001/12/01 07:30:31 zz Exp $
#
# ++Copyright LIBBK++
#
# Copyright (c) 2001 The Authors.  All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
#
# Production rules--convert "source" to "targets"
#

#
# Prevent make from being stupid about building makefile pieces
# (this is just a performance hack, but it helps)
Make%: 
.depen%:

#
# Standard compiling targets
#
%.o: %.c
	$(COMPILE.c) $(OUTPUT_OPTION) $<

%.i: %.c
	$(CC) -E $(CPPFLAGS) -o $@ $<

%.c: %.l
	$(LEX) $(LFLAGS) -t $< > $@

%.tab.c %.tab.h: %.y
	$(YACC) $(YFLAGS) $<

#
# Simple program production
#
$(BK_SIMPLE_INTERNALPROGS) $(BK_SIMPLE_PROGS): %: %.c $(filter -l%,$(BK_ALLLIBS))
	$(LINK.c) -o $@ $@.c $(LDLIBS)

#
# Larger program production
#
BK_LARGE_OBJ:=$(patsubst %.c,%.o,$(BK_LARGE_SRC))
BK_LARGE_OBJ:=$(patsubst %.y,%.tab.o,$(BK_LARGE_OBJ))
BK_LARGE_OBJ:=$(patsubst %.l,%.o,$(BK_LARGE_OBJ))

$(BK_LARGE_INTERNALPROG) $(BK_LARGE_PROG): $(BK_LARGE_OBJ) $(filter -l%,$(BK_ALLLIBS))
	$(LINK.c) -o $@ $(BK_LARGE_OBJ) $(LDLIBS)

#
# Large library production
#
BK_LARGE_LIBOBJ:=$(patsubst %.c,%.o,$(BK_LARGE_LIBSRC))
BK_LARGE_LIBOBJ:=$(patsubst %.y,%.tab.o,$(BK_LARGE_LIBOBJ))
BK_LARGE_LIBOBJ:=$(patsubst %.l,%.o,$(BK_LARGE_LIBOBJ))

$(BK_LARGE_INTERNALPROG) $(BK_LARGE_LIB): $(BK_LARGE_LIBOBJ)
	$(AR) $(ARFLAGS) $@ $?
	$(RANLIB) $@

#
# Java production
#

# Prevent make from trying to create foo.java from foo.java.c
.SUFFIXES: .class .java .properties .MF

# These two "pattern" rules will run the java compiler (once!) on
# entire groups of files, which is more efficient and reduces duplicated
# error messages, as implicitly compiled sources are only compiled once.
# This isn't really a pattern rule, but if it weren't the rule would be
# invoked once for each target (which is totally redundant).  So we get
# hacky and replace the stem "a" in .cl%ss and %.j%va so that make treats
# it like a pattern rule.  Amazingly enough, it works, as long as you don't
# have a real pattern rule %.class: %.java that builds things one at a time.

$(subst .class,.cl%ss,$(BK_JAVA_PKG_CLASS)): \
		$(subst .java,.j%va,$(BK_JAVA_PKG_SRC))
	$(JAVAC) $(JAVACFLAGS) -classpath $(BK_JAVADIR):$(BK_JAVA_CP) $?

$(subst .class,.cl%ss,$(BK_JAVA_PKG_TCLASS)): \
		$(subst .java,.j%va,$(BK_JAVA_PKG_TEST))
	$(JAVAC) $(JAVACFLAGS) -classpath $(BK_JAVADIR):$(BK_JAVA_CP) $?

$(BK_JAVADIR)/$(BK_JAVA_PKG)/%: %
	$(LN_S) -f `$(PWD)`/$< $@
	@-test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@

$(BK_JAVADIR)/%: $(GROUPTOP)/$(LOCALE)/%
	$(LN_S) -f `$(PWD)`/$< $@
	@-test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@

$(BK_JAVADIR)/%.MF: %.MF
	$(LN_S) -f `$(PWD)`/$< $@
	@-test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@

# BK_JAVA_ICLASS doesn't see newly created files, sigh
$(BK_JAVA_JAR): $(BK_JAVADIR)/$(BK_JAVA_PKG) $(BK_JAVADIR)/$(BK_JAVA_MF) \
		$(BK_JAVA_PKG_SRC) $(BK_JAVA_PKG_CLASS) \
		$(BK_JAVA_PKG_AUX) $(BK_JAVA_PKG_LOCALE)
	cd $(BK_JAVADIR) && \
	  $(JAR) $(JARFLAGS) $@ $(BK_JAVA_MF) $(BK_JAVA_CLASS) \
	    $(BK_JAVA_ICLASS) \
	    $(patsubst %,$(BK_JAVA_PKG)/%,$(BK_JAVA_AUX)) $(BK_JAVA_LOCALE)
	$(MV) $(BK_JAVADIR)/$(BK_JAVA_JAR) $@

$(BK_JAVADIR)/$(BK_JAVA_PKG):
	$(MKDIR) $(BK_JAVADIR)/$(BK_JAVA_PKG)
