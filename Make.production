# -*- makefile -*-
#
# $Id: Make.production,v 1.23 2002/01/04 19:41:50 dupuy Exp $
#
# ++Copyright LIBBK++
#
# Copyright (c) 2001,2002 The Authors.  All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
#
# Production rules--convert "source" to "targets"
#

#
# Prevent make from being stupid about building makefile pieces
# (this is just a performance hack, but it helps)
Make%: 
.depen%:

#
# Last-resort rule to make directories referenced in dependencies (must include
# trailing "/.").  Note that since directories' modified time gets updated on
# any file creation/deletion, use of these dependencies may cause spurious
# re-makes of targets that were not really out of date.  For the Java stuff
# that currently uses this, that isn't an issue (yet).
%/.:
	$(MKDIR) $*

# Keep make from trying to delete "implicit" directories created by above rule
# (it wouldn't be able to, but the unlink: Is a directory error is annoying
.PRECIOUS: %/.

#
# Standard compiling targets
#
%.o: %.c
	$(COMPILE.c) $(OUTPUT_OPTION) $<

%.i: %.c
	$(CC) -E $(CPPFLAGS) -o $@ $<

%.c: %.l
	$(LEX) $(LFLAGS) -t $< > $@

%.tab.c %.tab.h: %.y
	$(YACC) $(YFLAGS) $<

#
# Simple program production
#
$(BK_SIMPLE_INTERNALPROGS) $(BK_SIMPLE_PROGS): %: %.c $(filter -l%,$(BK_ALLLIBS))
	$(LINK.c) -o $@ $@.c $(LDLIBS)

#
# Larger program production
#
BK_LARGE_OBJ:=$(patsubst %.c,%.o,$(BK_LARGE_SRC))
BK_LARGE_OBJ:=$(patsubst %.y,%.tab.o,$(BK_LARGE_OBJ))
BK_LARGE_OBJ:=$(patsubst %.l,%.o,$(BK_LARGE_OBJ))

$(BK_LARGE_INTERNALPROG) $(BK_LARGE_PROG): $(BK_LARGE_OBJ) $(filter -l%,$(BK_ALLLIBS))
	$(LINK.c) -o $@ $(BK_LARGE_OBJ) $(LDLIBS)

#
# Large library production
#
BK_LARGE_LIBOBJ:=$(patsubst %.c,%.o,$(BK_LARGE_LIBSRC))
BK_LARGE_LIBOBJ:=$(patsubst %.y,%.tab.o,$(BK_LARGE_LIBOBJ))
BK_LARGE_LIBOBJ:=$(patsubst %.l,%.o,$(BK_LARGE_LIBOBJ))

$(BK_LARGE_LIB): $(BK_LARGE_LIBOBJ)
	if [ -f $@ ]; then \
	  $(AR) $(ARFLAGS) $@ $?; \
	else \
	  $(AR) $(ARFLAGS) $@ $^; \
	fi
	$(RANLIB) $@

#
# Java production
#

# Prevent make from deleting intermediate java and properties symlinks
.PRECIOUS: %.java %.properties

# Prevent make from trying to create foo.java from foo.java.c
.SUFFIXES: .class .java .properties .MF

# These two "pattern" rules will run the java compiler (once!) on
# entire groups of files, which is more efficient and reduces duplicated
# error messages, as implicitly compiled sources are only compiled once.
# This isn't really a pattern rule, but if it weren't the rule would be
# invoked once for each target (which is totally redundant).  So we get
# hacky and use a pseudo-stem "a" in .cl%ss and .j%va so that make treats
# it like a pattern rule.  Amazingly enough, it works, as long as you don't
# have a real pattern rule %.class: %.java that builds things one at a time.

$(subst .class,.cl%ss,$(BK_JAVA_PKG_CLASS)): \
		$(subst .java,.j%va,$(BK_JAVA_PKG_SRC))
	$(JAVAC) $(JAVACFLAGS) -classpath "$(BK_JAVA_CPATH)" $?

$(subst .class,.cl%ss,$(BK_JAVA_PKG_TCLASS)): \
		$(subst .java,.j%va,$(BK_JAVA_PKG_TEST))
	$(JAVAC) $(JAVACFLAGS) -classpath "$(BK_JAVA_TESTCP)" $?

$(BK_JAVADIR)/$(BK_JAVA_PKG)/%: % $(BK_JAVADIR)/$(BK_JAVA_PKG)/.
	$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVADIR)/%: $(GROUPTOP)/$(LOCALE)/% $(BK_JAVADIR)/.
	$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVADIR)/%: $(GROUPTOP)/% $(patsubst %,$(BK_JAVADIR)/%/.,$(IMAGES))
	$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVADIR)/%.MF: %.MF $(BK_JAVADIR)/.
	$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

# BK_JAVA_ICLASS doesn't see newly created files, sigh
$(BK_JAVA_JAR): $(BK_JAVADIR)/$(BK_JAVA_PKG)/. $(BK_JAVADIR)/$(BK_JAVA_MF) \
		$(BK_JAVA_PKG_SRC) $(BK_JAVA_PKG_CLASS) \
		$(BK_JAVA_PKG_AUX) $(BK_JAVA_PKG_LOCALE) $(BK_JAVA_PKG_IMAGES)
	cd $(BK_JAVADIR) && \
	  $(JAR) $(JARFLAGS) $@ $(BK_JAVA_MF) $(BK_JAVA_CLASS) \
	    $(BK_JAVA_ICLASS) \
	    $(patsubst %,$(BK_JAVA_PKG)/%,$(BK_JAVA_AUX)) \
	    $(BK_JAVA_LOCALE) $(BK_JAVA_IMAGES)
	$(MV) $(BK_JAVADIR)/$(BK_JAVA_JAR) $@

# Jtest productions

# Class test parameter generation rule; Jtest is only invoked if the .ctp file
# doesn't exist. "-run_only static_DBC" runs only the Design by Contract rules
# (just a few) so that we don't waste much time when generating the .ctp file
%.ctp: $(BK_JAVADIR)/$(BK_JAVA_PKG)/%.class
	@if [ -f $@ ]; then touch $@; else \
	$(JTEST) -nogui -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp_new $@ \
	  -class_name $(BK_JAVA_PKGDOT).$* -cp "$(BK_JAVA_TESTCP)" \
	  -silent -run_only static_DBC > /dev/null 2>&1 \
	; fi

%.rpt: %.ctp
	@echo $(JTEST) $(JTESTOUT) $*; \
	 $(JTEST) -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp $< \
	  -nogui -detail_report_html $*.htm > /dev/null 2>&1 \
	 || $(JTEST) -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp $< -silent \
	     $(JTESTOUT) -detail_report_ascii $*.err > /dev/null 2>&1 \
	 || $(JTESTERR)
	@mv $*.htm $@

jtest-%: %.ctp
	$(JTEST) -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp $< \
	 $(JTESTOUT) -detail_report_ascii $*.err > /dev/null 2>&1

.PHONY: $(patsubst %.java,jtest-%,$(BK_JAVA_SRC))
