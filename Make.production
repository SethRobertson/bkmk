# -*- makefile -*-
#
# $Id: Make.production,v 1.43 2002/07/29 18:58:38 jtt Exp $
#
# ++Copyright LIBBK++
#
# Copyright (c) 2001,2002 The Authors.  All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
#
# Production rules--convert "source" to "targets"
#

#
# Prevent make from being stupid about building makefile pieces
# (this is just a performance hack, but it helps)
Make%: 
.depen%:
.user-variable%:

#
# Last-resort rule to make directories referenced in dependencies (must include
# trailing "/.").  Note that since directories' modified time gets updated on
# any file creation/deletion, use of these dependencies may cause spurious
# re-makes of targets that were not really out of date.  For the Java stuff
# that currently uses this, that isn't an issue (yet).
%/.:
	$(MKDIR) $*

# Keep make from trying to delete "implicit" directories created by above rule
# (it wouldn't be able to, but the unlink: Is a directory error is annoying
.PRECIOUS: %/.

# just in case these aren't already on the suffixes list
.SUFFIXES: $(EXEEXT) $(LIBEXT) $(OBJEXT)

#
# Standard compiling targets
#
%$(OBJEXT): %.c
	$(LTCC) $(COMPILE.c) $(LT_CFLAGS) $(OUTPUT_OPTION) $<

%.i: %.c
	$(CC) -E $(CPPFLAGS) -o $@ $<

%.c: %.l
	$(LEX) $(LFLAGS) -t $< > $@

%.tab.c %.tab.h: %.y
	$(YACC) $(YFLAGS) $<

#
# <WARNING>The parts where $(BK_INSTALLRDIR) != $(BK_INSTALLRPATH) are quite
# hairy.  When doing a "production" install, with embedded rpath different from
# the install directory, libtool --mode install gets fussy and needs to find
# libraries that are dependencies of other libraries in the embedded runpath
# (where they may not yet, or ever, be installed).  Furthermore, when
# "installing" programs, libtool is unable to find the libraries in the
# embedded runpath, and installs the script wrappers instead of relinking.
#
# To prevent this, after running libtool -mode link on programs, we edit the
# wrapper scripts to prevent libtool from (a) complaining that libtool
# libraries that are dependencies of the program are not installed in the
# embedded runpath directory, and (b) appending the install directory into the
# native executable runpath.  Note that we need to do this in two places: for
# link of BK_SIMPLE_*PROGS and BK_LARGE_*PROGS.  On some platforms we might
# need to do these hacks for library/module linking as well, but that can wait
# until we discover it is necessary.
#
# Note that problem (b) is caused by the editing of the libtool library scripts
# we do in Make.targets; see the WARNING there for more details.</WARNING>
#

ifeq ($(BK_WANT_LIBTOOL),true)
EDIT_LT_PROGLINK=\
	if [ $(BK_INSTALLRDIR) != $(BK_INSTALLRPATH) ]; then \
	  $(PERL) -pi -e " \
	    s|\S*(/[^/\s]*\.la)|$(BK_INSTALLRDIR)\1|g \
	      if (/notinst_deplibs=/); \
	    s|([,])$(BK_INSTALLRDIR)|\1$(BK_INSTALLRPATH)|g \
	      if (/^relink_command=/);"  $@; \
	fi
else
EDIT_LT_PROGLINK=
endif

#
# Simple program production
#
ifeq ($(BK_WANT_LIBTOOL),true)
ifeq ($(BK_USING_INSURE),true)
# Insure++ often generates exceedingly bogus errors when it compiles and links
# in a single command, so make the dependency on the object file and link that.
$(BK_SIMPLE_INTERNALPROGS) $(BK_SIMPLE_PROGS): %: %$(OBJEXT) $(filter -l%,$(BK_ALLLIBS))
# [may not need rpath for insure-linked programs; let's see if it helps]
	$(LTLD) $(LINK.c) $(LT_LDFLAGS) -o $@ $@$(OBJEXT) $(LDLIBS) -rpath $(BK_INSTALLRPATH)
else
$(BK_SIMPLE_INTERNALPROGS) $(BK_SIMPLE_PROGS): %: %.c $(filter -l%,$(BK_ALLLIBS))
	$(LTLD) $(LINK.c) $(LT_LDFLAGS) -o $@ $@.c $(LDLIBS) -rpath $(BK_INSTALLRPATH)
	@$(EDIT_LT_PROGLINK)
endif
else
ifeq ($(BK_USING_INSURE),true)
# Insure++ often generates exceedingly bogus errors when it compiles and links
# in a single command, so make the dependency on the object file and link that.
$(BK_SIMPLE_INTERNALPROGS) $(BK_SIMPLE_PROGS): %: %$(OBJEXT) $(filter -l%,$(BK_ALLLIBS))
# [may not need rpath for insure-linked programs; let's see if it helps]
	$(LTLD) $(LINK.c) $(LT_LDFLAGS) -o $@ $@$(OBJEXT) $(LDLIBS)
else
$(BK_SIMPLE_INTERNALPROGS) $(BK_SIMPLE_PROGS): %: %.c $(filter -l%,$(BK_ALLLIBS))
	$(LTLD) $(LINK.c) $(LT_LDFLAGS) -o $@ $@.c $(LDLIBS)
endif
endif
#
# Larger program production
#
BK_LARGE_OBJ:=$(patsubst %.c,%$(OBJEXT),$(BK_LARGE_SRC))
BK_LARGE_OBJ:=$(patsubst %.y,%.tab$(OBJEXT),$(BK_LARGE_OBJ))
BK_LARGE_OBJ:=$(patsubst %.l,%$(OBJEXT),$(BK_LARGE_OBJ))

ifeq ($(BK_WANT_LIBTOOL),true)
$(BK_LARGE_INTERNALPROG) $(BK_LARGE_PROG): $(BK_LARGE_OBJ) $(filter -l%,$(BK_ALLLIBS))
	$(LTLD) $(LINK.c) $(LT_LDFLAGS) -o $@ $(BK_LARGE_OBJ) $(LDLIBS) -rpath $(BK_INSTALLRPATH)
	@$(EDIT_LT_PROGLINK)
else
$(BK_LARGE_INTERNALPROG) $(BK_LARGE_PROG): $(BK_LARGE_OBJ) $(filter -l%,$(BK_ALLLIBS))
	$(LTLD) $(LINK.c) $(LT_LDFLAGS) -o $@ $(BK_LARGE_OBJ) $(LDLIBS)
endif

#
# Large library production
#
BK_LARGE_LIBOBJ:=$(patsubst %.c,%$(OBJEXT),$(BK_LARGE_LIBSRC))
BK_LARGE_LIBOBJ:=$(patsubst %.y,%.tab$(OBJEXT),$(BK_LARGE_LIBOBJ))
BK_LARGE_LIBOBJ:=$(patsubst %.l,%$(OBJEXT),$(BK_LARGE_LIBOBJ))

# Even if target doesn't exist, $? may not contain all dependencies since
# vpath search may find installed version of static library that isn't quite
# up to date.  So make sure that new files get all dependencies.
$(filter %.a,$(BK_LARGE_LIB)): $(BK_LARGE_LIBOBJ)
	@if [ -f $@ ]; then \
	  echo $(AR) $(ARFLAGS) $@ $?; \
	  $(AR) $(ARFLAGS) $@ $?; \
	else \
	  echo $(AR) $(ARFLAGS) $@ $^; \
	  $(AR) $(ARFLAGS) $@ $^; \
	fi
	$(RANLIB) $@

# don't use $(LDLIBS) in libtool links, as it may contain static/convenience
# libs that will get included in the generated shared library.
ifeq ($(BK_WANT_LIBTOOL),true)
$(filter %.la,$(BK_LARGE_LIB)): $(BK_LARGE_LIBOBJ)
	-@$(MKDIR) $(BK_INSTALLRDIR) >/dev/null 2>&1
	$(LIBTOOL_LINK) $(LINK.c) $(LT_LDFLAGS) -o $@ $^ $(LT_LDLIBS) \
	 -rpath $(BK_INSTALLRPATH)

$(BK_LARGE_MODULE): $(BK_LARGE_LIBOBJ)
	-@$(MKDIR) $(BK_INSTALLRDIR) >/dev/null 2>&1
	$(LIBTOOL_LINK) $(LINK.c) $(LT_M_LDFLAGS) -o $@ $^ $(LT_LDLIBS) \
	 -rpath $(BK_INSTALLRPATH)

else
$(BK_LARGE_MODULE): $(BK_LARGE_LIBOBJ)
	@if [ -f $@ ]; then \
	  echo $(AR) $(ARFLAGS) $@ $?; \
	  $(AR) $(ARFLAGS) $@ $?; \
	else \
	  echo $(AR) $(ARFLAGS) $@ $^; \
	  $(AR) $(ARFLAGS) $@ $^; \
	fi
	$(RANLIB) $@
endif

#
# Java production
#

# Prevent make from deleting intermediate java and properties symlinks
.PRECIOUS: $(BK_JAVADIR)/$(BK_JAVA_PKG)/%

# Prevent make from trying to create foo.java from foo.java.c
.SUFFIXES: .class .java .properties .MF

# These two "pattern" rules will run the java compiler (once!) on
# entire groups of files, which is more efficient and reduces duplicated
# error messages, as implicitly compiled sources are only compiled once.
# This isn't really a pattern rule, but if it weren't the rule would be
# invoked once for each target (which is totally redundant).  So we get
# hacky and use a pseudo-stem "a" in .cl%ss and .j%va so that make treats
# it like a pattern rule.  Amazingly enough, it works, as long as you don't
# have a real pattern rule %.class: %.java that builds things one at a time.
#
# Note that you need to use $^ rather than $? so that all dependencies are
# listed; with $? only those .java files that are newer than the first
# out-of-date .class file will be regenerated, and the jar building stage will
# complain about missing .class files (but won't fail).

$(subst .class,.cl%ss,$(BK_JAVA_PKG_CLASS)): \
		$(subst .java,.j%va,$(BK_JAVA_PKG_SRC))
	@echo $(JAVAC) $(JAVACFLAGS) -cp "$(BK_JAVA_CPATH)" $(BK_JAVA_SRC)
	@$(JAVAC) $(JAVACFLAGS) -classpath "$(BK_JAVA_CPATH)" $^

$(subst .class,.cl%ss,$(BK_JAVA_PKG_TCLASS)): \
		$(subst .java,.j%va,$(BK_JAVA_PKG_TEST))
	@echo $(JAVAC) $(JAVACFLAGS) -cp "$(BK_JAVA_CPATH)" $(BK_JAVA_TEST)
	@$(JAVAC) $(JAVACFLAGS) -classpath "$(BK_JAVA_TESTCP)" $^

$(BK_JAVADIR)/$(BK_JAVA_PKG)/%: % $(BK_JAVADIR)/$(BK_JAVA_PKG)/.
	@$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVADIR)/%: $(GROUPTOP)/$(LOCALE)/% $(BK_JAVADIR)/.
	@$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVADIR)/%: $(GROUPTOP)/% $(patsubst %,$(BK_JAVADIR)/%/.,$(IMAGES))
	@$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVADIR)/%.MF: %.MF $(BK_JAVADIR)/.
	@$(LN_S) -f $(CURDIR)/$< $@
	@test ! -L $@ && test ! $@ -ef $< 2>/dev/null && chmod -w $@ || true

$(BK_JAVA_JAR): $(BK_JAVADIR)/$(BK_JAVA_PKG)/. $(BK_JAVADIR)/$(BK_JAVA_MF) \
		$(BK_JAVA_PKG_SRC) $(BK_JAVA_PKG_CLASS) \
		$(BK_JAVA_PKG_AUX) $(BK_JAVA_PKG_LOCALE) $(BK_JAVA_PKG_IMAGES)
	@echo $(JAR) $(JARFLAGS) $@ $(BK_JAVA_MF) ...
	@cd $(BK_JAVADIR) && \
	  $(JAR) $(JARFLAGS) $@ $(BK_JAVA_MF) $(BK_JAVA_CLASS) \
	    $(BK_JAVA_ICLASS) \
	    $(patsubst %,$(BK_JAVA_PKG)/%,$(BK_JAVA_AUX)) \
	    $(BK_JAVA_LOCALE) $(BK_JAVA_IMAGES)
	$(MV) $(BK_JAVADIR)/$(BK_JAVA_JAR) $@

# Jtest productions

# Class test parameter generation rule; Jtest is only invoked if the .ctp file
# doesn't exist. "-run_only static_DBC" runs only the Design by Contract rules
# (just a few) so that we don't waste much time when generating the .ctp file
%.ctp: $(BK_JAVADIR)/$(BK_JAVA_PKG)/%.class
	@if [ -f $@ ]; then touch $@; else \
	$(JTEST) -nogui -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp_new $@ \
	  -class_name $(BK_JAVA_PKGDOT).$* -cp "$(BK_JAVA_TESTCP)" \
	  -silent -run_only static_DBC > /dev/null 2>&1 \
	; fi

%.rpt: %.ctp
	@echo $(JTEST) $(JTESTOUT) $*; \
	 $(JTEST) -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp $< \
	  -nogui -detail_report_html $*.htm > /dev/null 2>&1 \
	 || $(JTEST) -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp $< -silent \
	     $(JTESTOUT) -detail_report_ascii $*.err > /dev/null 2>&1 \
	 || $(JTESTERR)
	@mv $*.htm $@

jtest-%: %.ctp
	$(JTEST) -gtp $(GROUPTOP)/$(PKGSUBDIR).gtp -ctp $< \
	 $(JTESTOUT) -detail_report_ascii $*.err > /dev/null 2>&1
